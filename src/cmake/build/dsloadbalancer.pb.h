// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dsloadbalancer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dsloadbalancer_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_dsloadbalancer_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_dsloadbalancer_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dsloadbalancer_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_dsloadbalancer_2eproto;
namespace dsloadbalancer {
class BulkGetRequest;
struct BulkGetRequestDefaultTypeInternal;
extern BulkGetRequestDefaultTypeInternal _BulkGetRequest_default_instance_;
class BulkPutResponse;
struct BulkPutResponseDefaultTypeInternal;
extern BulkPutResponseDefaultTypeInternal _BulkPutResponse_default_instance_;
class KVPair;
struct KVPairDefaultTypeInternal;
extern KVPairDefaultTypeInternal _KVPair_default_instance_;
class PingMessage;
struct PingMessageDefaultTypeInternal;
extern PingMessageDefaultTypeInternal _PingMessage_default_instance_;
class PingResponse;
struct PingResponseDefaultTypeInternal;
extern PingResponseDefaultTypeInternal _PingResponse_default_instance_;
class Result;
struct ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class TaskInfo;
struct TaskInfoDefaultTypeInternal;
extern TaskInfoDefaultTypeInternal _TaskInfo_default_instance_;
}  // namespace dsloadbalancer
PROTOBUF_NAMESPACE_OPEN
template <>
::dsloadbalancer::BulkGetRequest* Arena::CreateMaybeMessage<::dsloadbalancer::BulkGetRequest>(Arena*);
template <>
::dsloadbalancer::BulkPutResponse* Arena::CreateMaybeMessage<::dsloadbalancer::BulkPutResponse>(Arena*);
template <>
::dsloadbalancer::KVPair* Arena::CreateMaybeMessage<::dsloadbalancer::KVPair>(Arena*);
template <>
::dsloadbalancer::PingMessage* Arena::CreateMaybeMessage<::dsloadbalancer::PingMessage>(Arena*);
template <>
::dsloadbalancer::PingResponse* Arena::CreateMaybeMessage<::dsloadbalancer::PingResponse>(Arena*);
template <>
::dsloadbalancer::Result* Arena::CreateMaybeMessage<::dsloadbalancer::Result>(Arena*);
template <>
::dsloadbalancer::TaskInfo* Arena::CreateMaybeMessage<::dsloadbalancer::TaskInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace dsloadbalancer {

// ===================================================================


// -------------------------------------------------------------------

class KVPair final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dsloadbalancer.KVPair) */ {
 public:
  inline KVPair() : KVPair(nullptr) {}
  ~KVPair() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR KVPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KVPair(const KVPair& from);
  KVPair(KVPair&& from) noexcept
    : KVPair() {
    *this = ::std::move(from);
  }

  inline KVPair& operator=(const KVPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline KVPair& operator=(KVPair&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KVPair& default_instance() {
    return *internal_default_instance();
  }
  static inline const KVPair* internal_default_instance() {
    return reinterpret_cast<const KVPair*>(
               &_KVPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(KVPair& a, KVPair& b) {
    a.Swap(&b);
  }
  inline void Swap(KVPair* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KVPair* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KVPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KVPair>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KVPair& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KVPair& from) {
    KVPair::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVPair* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dsloadbalancer.KVPair";
  }
  protected:
  explicit KVPair(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int32 key = 1;
  void clear_key() ;
  ::int32_t key() const;
  void set_key(::int32_t value);

  private:
  ::int32_t _internal_key() const;
  void _internal_set_key(::int32_t value);

  public:
  // int32 value = 2;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dsloadbalancer.KVPair)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t key_;
    ::int32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dsloadbalancer_2eproto;
};// -------------------------------------------------------------------

class BulkPutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dsloadbalancer.BulkPutResponse) */ {
 public:
  inline BulkPutResponse() : BulkPutResponse(nullptr) {}
  ~BulkPutResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BulkPutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BulkPutResponse(const BulkPutResponse& from);
  BulkPutResponse(BulkPutResponse&& from) noexcept
    : BulkPutResponse() {
    *this = ::std::move(from);
  }

  inline BulkPutResponse& operator=(const BulkPutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkPutResponse& operator=(BulkPutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BulkPutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BulkPutResponse* internal_default_instance() {
    return reinterpret_cast<const BulkPutResponse*>(
               &_BulkPutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BulkPutResponse& a, BulkPutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkPutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BulkPutResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BulkPutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BulkPutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BulkPutResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BulkPutResponse& from) {
    BulkPutResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkPutResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dsloadbalancer.BulkPutResponse";
  }
  protected:
  explicit BulkPutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dsloadbalancer.BulkPutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dsloadbalancer_2eproto;
};// -------------------------------------------------------------------

class BulkGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dsloadbalancer.BulkGetRequest) */ {
 public:
  inline BulkGetRequest() : BulkGetRequest(nullptr) {}
  ~BulkGetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BulkGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BulkGetRequest(const BulkGetRequest& from);
  BulkGetRequest(BulkGetRequest&& from) noexcept
    : BulkGetRequest() {
    *this = ::std::move(from);
  }

  inline BulkGetRequest& operator=(const BulkGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkGetRequest& operator=(BulkGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BulkGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BulkGetRequest* internal_default_instance() {
    return reinterpret_cast<const BulkGetRequest*>(
               &_BulkGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BulkGetRequest& a, BulkGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BulkGetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BulkGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BulkGetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BulkGetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BulkGetRequest& from) {
    BulkGetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dsloadbalancer.BulkGetRequest";
  }
  protected:
  explicit BulkGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
  };
  // repeated int32 keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  ::int32_t keys(int index) const;
  void set_keys(int index, ::int32_t value);
  void add_keys(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* mutable_keys();

  private:
  ::int32_t _internal_keys(int index) const;
  void _internal_add_keys(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& _internal_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* _internal_mutable_keys();

  public:
  // @@protoc_insertion_point(class_scope:dsloadbalancer.BulkGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t> keys_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _keys_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dsloadbalancer_2eproto;
};// -------------------------------------------------------------------

class PingMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dsloadbalancer.PingMessage) */ {
 public:
  inline PingMessage() : PingMessage(nullptr) {}
  ~PingMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PingMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingMessage(const PingMessage& from);
  PingMessage(PingMessage&& from) noexcept
    : PingMessage() {
    *this = ::std::move(from);
  }

  inline PingMessage& operator=(const PingMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingMessage& operator=(PingMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingMessage* internal_default_instance() {
    return reinterpret_cast<const PingMessage*>(
               &_PingMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PingMessage& a, PingMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PingMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PingMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PingMessage& from) {
    PingMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dsloadbalancer.PingMessage";
  }
  protected:
  explicit PingMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // string ip = 1;
  void clear_ip() ;
  const std::string& ip() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ptr);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // string port = 2;
  void clear_port() ;
  const std::string& port() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_port(Arg_&& arg, Args_... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* ptr);

  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(
      const std::string& value);
  std::string* _internal_mutable_port();

  public:
  // @@protoc_insertion_point(class_scope:dsloadbalancer.PingMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dsloadbalancer_2eproto;
};// -------------------------------------------------------------------

class PingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dsloadbalancer.PingResponse) */ {
 public:
  inline PingResponse() : PingResponse(nullptr) {}
  ~PingResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingResponse(const PingResponse& from);
  PingResponse(PingResponse&& from) noexcept
    : PingResponse() {
    *this = ::std::move(from);
  }

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingResponse& operator=(PingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingResponse* internal_default_instance() {
    return reinterpret_cast<const PingResponse*>(
               &_PingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PingResponse& a, PingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PingResponse& from) {
    PingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dsloadbalancer.PingResponse";
  }
  protected:
  explicit PingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 2,
    kPortFieldNumber = 3,
    kTypeFieldNumber = 4,
    kIsAliveFieldNumber = 1,
  };
  // string ip = 2;
  void clear_ip() ;
  const std::string& ip() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ptr);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // string port = 3;
  void clear_port() ;
  const std::string& port() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_port(Arg_&& arg, Args_... args);
  std::string* mutable_port();
  PROTOBUF_NODISCARD std::string* release_port();
  void set_allocated_port(std::string* ptr);

  private:
  const std::string& _internal_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_port(
      const std::string& value);
  std::string* _internal_mutable_port();

  public:
  // string type = 4;
  void clear_type() ;
  const std::string& type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // bool isAlive = 1;
  void clear_isalive() ;
  bool isalive() const;
  void set_isalive(bool value);

  private:
  bool _internal_isalive() const;
  void _internal_set_isalive(bool value);

  public:
  // @@protoc_insertion_point(class_scope:dsloadbalancer.PingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr port_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    bool isalive_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dsloadbalancer_2eproto;
};// -------------------------------------------------------------------

class TaskInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dsloadbalancer.TaskInfo) */ {
 public:
  inline TaskInfo() : TaskInfo(nullptr) {}
  ~TaskInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TaskInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskInfo(const TaskInfo& from);
  TaskInfo(TaskInfo&& from) noexcept
    : TaskInfo() {
    *this = ::std::move(from);
  }

  inline TaskInfo& operator=(const TaskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskInfo& operator=(TaskInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskInfo* internal_default_instance() {
    return reinterpret_cast<const TaskInfo*>(
               &_TaskInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TaskInfo& a, TaskInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskInfo& from) {
    TaskInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dsloadbalancer.TaskInfo";
  }
  protected:
  explicit TaskInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkerNodeIpFieldNumber = 4,
    kWorkerNodePortFieldNumber = 5,
    kStorageNodeIpFieldNumber = 6,
    kStorageNodePortFieldNumber = 7,
    kDataSizeFieldNumber = 1,
    kMinKeyFieldNumber = 2,
    kMaxKeyFieldNumber = 3,
  };
  // string workerNodeIp = 4;
  void clear_workernodeip() ;
  const std::string& workernodeip() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_workernodeip(Arg_&& arg, Args_... args);
  std::string* mutable_workernodeip();
  PROTOBUF_NODISCARD std::string* release_workernodeip();
  void set_allocated_workernodeip(std::string* ptr);

  private:
  const std::string& _internal_workernodeip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workernodeip(
      const std::string& value);
  std::string* _internal_mutable_workernodeip();

  public:
  // string workerNodePort = 5;
  void clear_workernodeport() ;
  const std::string& workernodeport() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_workernodeport(Arg_&& arg, Args_... args);
  std::string* mutable_workernodeport();
  PROTOBUF_NODISCARD std::string* release_workernodeport();
  void set_allocated_workernodeport(std::string* ptr);

  private:
  const std::string& _internal_workernodeport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workernodeport(
      const std::string& value);
  std::string* _internal_mutable_workernodeport();

  public:
  // string storageNodeIp = 6;
  void clear_storagenodeip() ;
  const std::string& storagenodeip() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_storagenodeip(Arg_&& arg, Args_... args);
  std::string* mutable_storagenodeip();
  PROTOBUF_NODISCARD std::string* release_storagenodeip();
  void set_allocated_storagenodeip(std::string* ptr);

  private:
  const std::string& _internal_storagenodeip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_storagenodeip(
      const std::string& value);
  std::string* _internal_mutable_storagenodeip();

  public:
  // string storageNodePort = 7;
  void clear_storagenodeport() ;
  const std::string& storagenodeport() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_storagenodeport(Arg_&& arg, Args_... args);
  std::string* mutable_storagenodeport();
  PROTOBUF_NODISCARD std::string* release_storagenodeport();
  void set_allocated_storagenodeport(std::string* ptr);

  private:
  const std::string& _internal_storagenodeport() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_storagenodeport(
      const std::string& value);
  std::string* _internal_mutable_storagenodeport();

  public:
  // int32 dataSize = 1;
  void clear_datasize() ;
  ::int32_t datasize() const;
  void set_datasize(::int32_t value);

  private:
  ::int32_t _internal_datasize() const;
  void _internal_set_datasize(::int32_t value);

  public:
  // int32 minKey = 2;
  void clear_minkey() ;
  ::int32_t minkey() const;
  void set_minkey(::int32_t value);

  private:
  ::int32_t _internal_minkey() const;
  void _internal_set_minkey(::int32_t value);

  public:
  // int32 maxKey = 3;
  void clear_maxkey() ;
  ::int32_t maxkey() const;
  void set_maxkey(::int32_t value);

  private:
  ::int32_t _internal_maxkey() const;
  void _internal_set_maxkey(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dsloadbalancer.TaskInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workernodeip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workernodeport_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr storagenodeip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr storagenodeport_;
    ::int32_t datasize_;
    ::int32_t minkey_;
    ::int32_t maxkey_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dsloadbalancer_2eproto;
};// -------------------------------------------------------------------

class Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dsloadbalancer.Result) */ {
 public:
  inline Result() : Result(nullptr) {}
  ~Result() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Result(const Result& from);
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }
  inline void Swap(Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Result* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Result& from) {
    Result::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "dsloadbalancer.Result";
  }
  protected:
  explicit Result(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashMapFieldNumber = 1,
  };
  // repeated .dsloadbalancer.KVPair hashMap = 1;
  int hashmap_size() const;
  private:
  int _internal_hashmap_size() const;

  public:
  void clear_hashmap() ;
  ::dsloadbalancer::KVPair* mutable_hashmap(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dsloadbalancer::KVPair >*
      mutable_hashmap();
  private:
  const ::dsloadbalancer::KVPair& _internal_hashmap(int index) const;
  ::dsloadbalancer::KVPair* _internal_add_hashmap();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::dsloadbalancer::KVPair>& _internal_hashmap() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::dsloadbalancer::KVPair>* _internal_mutable_hashmap();
  public:
  const ::dsloadbalancer::KVPair& hashmap(int index) const;
  ::dsloadbalancer::KVPair* add_hashmap();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dsloadbalancer::KVPair >&
      hashmap() const;
  // @@protoc_insertion_point(class_scope:dsloadbalancer.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dsloadbalancer::KVPair > hashmap_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dsloadbalancer_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// KVPair

// int32 key = 1;
inline void KVPair::clear_key() {
  _impl_.key_ = 0;
}
inline ::int32_t KVPair::key() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.KVPair.key)
  return _internal_key();
}
inline void KVPair::set_key(::int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:dsloadbalancer.KVPair.key)
}
inline ::int32_t KVPair::_internal_key() const {
  return _impl_.key_;
}
inline void KVPair::_internal_set_key(::int32_t value) {
  ;
  _impl_.key_ = value;
}

// int32 value = 2;
inline void KVPair::clear_value() {
  _impl_.value_ = 0;
}
inline ::int32_t KVPair::value() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.KVPair.value)
  return _internal_value();
}
inline void KVPair::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:dsloadbalancer.KVPair.value)
}
inline ::int32_t KVPair::_internal_value() const {
  return _impl_.value_;
}
inline void KVPair::_internal_set_value(::int32_t value) {
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// BulkPutResponse

// bool success = 1;
inline void BulkPutResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool BulkPutResponse::success() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.BulkPutResponse.success)
  return _internal_success();
}
inline void BulkPutResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:dsloadbalancer.BulkPutResponse.success)
}
inline bool BulkPutResponse::_internal_success() const {
  return _impl_.success_;
}
inline void BulkPutResponse::_internal_set_success(bool value) {
  ;
  _impl_.success_ = value;
}

// -------------------------------------------------------------------

// BulkGetRequest

// repeated int32 keys = 1;
inline int BulkGetRequest::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int BulkGetRequest::keys_size() const {
  return _internal_keys_size();
}
inline void BulkGetRequest::clear_keys() {
  _internal_mutable_keys()->Clear();
}
inline ::int32_t BulkGetRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.BulkGetRequest.keys)
  return _internal_keys(index);
}
inline void BulkGetRequest::set_keys(int index, ::int32_t value) {
  _internal_mutable_keys()->Set(index, value);
  // @@protoc_insertion_point(field_set:dsloadbalancer.BulkGetRequest.keys)
}
inline void BulkGetRequest::add_keys(::int32_t value) {
  _internal_add_keys(value);
  // @@protoc_insertion_point(field_add:dsloadbalancer.BulkGetRequest.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& BulkGetRequest::keys() const {
  // @@protoc_insertion_point(field_list:dsloadbalancer.BulkGetRequest.keys)
  return _internal_keys();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* BulkGetRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:dsloadbalancer.BulkGetRequest.keys)
  return _internal_mutable_keys();
}

inline ::int32_t BulkGetRequest::_internal_keys(int index) const {
  return _internal_keys().Get(index);
}
inline void BulkGetRequest::_internal_add_keys(::int32_t value) {
  _internal_mutable_keys()->Add(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& BulkGetRequest::_internal_keys() const {
  return _impl_.keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* BulkGetRequest::_internal_mutable_keys() {
  return &_impl_.keys_;
}

// -------------------------------------------------------------------

// PingMessage

// string ip = 1;
inline void PingMessage::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& PingMessage::ip() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.PingMessage.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PingMessage::set_ip(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dsloadbalancer.PingMessage.ip)
}
inline std::string* PingMessage::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:dsloadbalancer.PingMessage.ip)
  return _s;
}
inline const std::string& PingMessage::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void PingMessage::_internal_set_ip(const std::string& value) {
  ;


  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* PingMessage::_internal_mutable_ip() {
  ;
  return _impl_.ip_.Mutable( GetArenaForAllocation());
}
inline std::string* PingMessage::release_ip() {
  // @@protoc_insertion_point(field_release:dsloadbalancer.PingMessage.ip)
  return _impl_.ip_.Release();
}
inline void PingMessage::set_allocated_ip(std::string* value) {
  _impl_.ip_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dsloadbalancer.PingMessage.ip)
}

// string port = 2;
inline void PingMessage::clear_port() {
  _impl_.port_.ClearToEmpty();
}
inline const std::string& PingMessage::port() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.PingMessage.port)
  return _internal_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PingMessage::set_port(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.port_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dsloadbalancer.PingMessage.port)
}
inline std::string* PingMessage::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:dsloadbalancer.PingMessage.port)
  return _s;
}
inline const std::string& PingMessage::_internal_port() const {
  return _impl_.port_.Get();
}
inline void PingMessage::_internal_set_port(const std::string& value) {
  ;


  _impl_.port_.Set(value, GetArenaForAllocation());
}
inline std::string* PingMessage::_internal_mutable_port() {
  ;
  return _impl_.port_.Mutable( GetArenaForAllocation());
}
inline std::string* PingMessage::release_port() {
  // @@protoc_insertion_point(field_release:dsloadbalancer.PingMessage.port)
  return _impl_.port_.Release();
}
inline void PingMessage::set_allocated_port(std::string* value) {
  _impl_.port_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.port_.IsDefault()) {
          _impl_.port_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dsloadbalancer.PingMessage.port)
}

// -------------------------------------------------------------------

// PingResponse

// bool isAlive = 1;
inline void PingResponse::clear_isalive() {
  _impl_.isalive_ = false;
}
inline bool PingResponse::isalive() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.PingResponse.isAlive)
  return _internal_isalive();
}
inline void PingResponse::set_isalive(bool value) {
  _internal_set_isalive(value);
  // @@protoc_insertion_point(field_set:dsloadbalancer.PingResponse.isAlive)
}
inline bool PingResponse::_internal_isalive() const {
  return _impl_.isalive_;
}
inline void PingResponse::_internal_set_isalive(bool value) {
  ;
  _impl_.isalive_ = value;
}

// string ip = 2;
inline void PingResponse::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& PingResponse::ip() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.PingResponse.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PingResponse::set_ip(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dsloadbalancer.PingResponse.ip)
}
inline std::string* PingResponse::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:dsloadbalancer.PingResponse.ip)
  return _s;
}
inline const std::string& PingResponse::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void PingResponse::_internal_set_ip(const std::string& value) {
  ;


  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* PingResponse::_internal_mutable_ip() {
  ;
  return _impl_.ip_.Mutable( GetArenaForAllocation());
}
inline std::string* PingResponse::release_ip() {
  // @@protoc_insertion_point(field_release:dsloadbalancer.PingResponse.ip)
  return _impl_.ip_.Release();
}
inline void PingResponse::set_allocated_ip(std::string* value) {
  _impl_.ip_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dsloadbalancer.PingResponse.ip)
}

// string port = 3;
inline void PingResponse::clear_port() {
  _impl_.port_.ClearToEmpty();
}
inline const std::string& PingResponse::port() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.PingResponse.port)
  return _internal_port();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PingResponse::set_port(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.port_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dsloadbalancer.PingResponse.port)
}
inline std::string* PingResponse::mutable_port() {
  std::string* _s = _internal_mutable_port();
  // @@protoc_insertion_point(field_mutable:dsloadbalancer.PingResponse.port)
  return _s;
}
inline const std::string& PingResponse::_internal_port() const {
  return _impl_.port_.Get();
}
inline void PingResponse::_internal_set_port(const std::string& value) {
  ;


  _impl_.port_.Set(value, GetArenaForAllocation());
}
inline std::string* PingResponse::_internal_mutable_port() {
  ;
  return _impl_.port_.Mutable( GetArenaForAllocation());
}
inline std::string* PingResponse::release_port() {
  // @@protoc_insertion_point(field_release:dsloadbalancer.PingResponse.port)
  return _impl_.port_.Release();
}
inline void PingResponse::set_allocated_port(std::string* value) {
  _impl_.port_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.port_.IsDefault()) {
          _impl_.port_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dsloadbalancer.PingResponse.port)
}

// string type = 4;
inline void PingResponse::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& PingResponse::type() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.PingResponse.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PingResponse::set_type(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dsloadbalancer.PingResponse.type)
}
inline std::string* PingResponse::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:dsloadbalancer.PingResponse.type)
  return _s;
}
inline const std::string& PingResponse::_internal_type() const {
  return _impl_.type_.Get();
}
inline void PingResponse::_internal_set_type(const std::string& value) {
  ;


  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* PingResponse::_internal_mutable_type() {
  ;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* PingResponse::release_type() {
  // @@protoc_insertion_point(field_release:dsloadbalancer.PingResponse.type)
  return _impl_.type_.Release();
}
inline void PingResponse::set_allocated_type(std::string* value) {
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dsloadbalancer.PingResponse.type)
}

// -------------------------------------------------------------------

// TaskInfo

// int32 dataSize = 1;
inline void TaskInfo::clear_datasize() {
  _impl_.datasize_ = 0;
}
inline ::int32_t TaskInfo::datasize() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.TaskInfo.dataSize)
  return _internal_datasize();
}
inline void TaskInfo::set_datasize(::int32_t value) {
  _internal_set_datasize(value);
  // @@protoc_insertion_point(field_set:dsloadbalancer.TaskInfo.dataSize)
}
inline ::int32_t TaskInfo::_internal_datasize() const {
  return _impl_.datasize_;
}
inline void TaskInfo::_internal_set_datasize(::int32_t value) {
  ;
  _impl_.datasize_ = value;
}

// int32 minKey = 2;
inline void TaskInfo::clear_minkey() {
  _impl_.minkey_ = 0;
}
inline ::int32_t TaskInfo::minkey() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.TaskInfo.minKey)
  return _internal_minkey();
}
inline void TaskInfo::set_minkey(::int32_t value) {
  _internal_set_minkey(value);
  // @@protoc_insertion_point(field_set:dsloadbalancer.TaskInfo.minKey)
}
inline ::int32_t TaskInfo::_internal_minkey() const {
  return _impl_.minkey_;
}
inline void TaskInfo::_internal_set_minkey(::int32_t value) {
  ;
  _impl_.minkey_ = value;
}

// int32 maxKey = 3;
inline void TaskInfo::clear_maxkey() {
  _impl_.maxkey_ = 0;
}
inline ::int32_t TaskInfo::maxkey() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.TaskInfo.maxKey)
  return _internal_maxkey();
}
inline void TaskInfo::set_maxkey(::int32_t value) {
  _internal_set_maxkey(value);
  // @@protoc_insertion_point(field_set:dsloadbalancer.TaskInfo.maxKey)
}
inline ::int32_t TaskInfo::_internal_maxkey() const {
  return _impl_.maxkey_;
}
inline void TaskInfo::_internal_set_maxkey(::int32_t value) {
  ;
  _impl_.maxkey_ = value;
}

// string workerNodeIp = 4;
inline void TaskInfo::clear_workernodeip() {
  _impl_.workernodeip_.ClearToEmpty();
}
inline const std::string& TaskInfo::workernodeip() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.TaskInfo.workerNodeIp)
  return _internal_workernodeip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskInfo::set_workernodeip(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.workernodeip_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dsloadbalancer.TaskInfo.workerNodeIp)
}
inline std::string* TaskInfo::mutable_workernodeip() {
  std::string* _s = _internal_mutable_workernodeip();
  // @@protoc_insertion_point(field_mutable:dsloadbalancer.TaskInfo.workerNodeIp)
  return _s;
}
inline const std::string& TaskInfo::_internal_workernodeip() const {
  return _impl_.workernodeip_.Get();
}
inline void TaskInfo::_internal_set_workernodeip(const std::string& value) {
  ;


  _impl_.workernodeip_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskInfo::_internal_mutable_workernodeip() {
  ;
  return _impl_.workernodeip_.Mutable( GetArenaForAllocation());
}
inline std::string* TaskInfo::release_workernodeip() {
  // @@protoc_insertion_point(field_release:dsloadbalancer.TaskInfo.workerNodeIp)
  return _impl_.workernodeip_.Release();
}
inline void TaskInfo::set_allocated_workernodeip(std::string* value) {
  _impl_.workernodeip_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.workernodeip_.IsDefault()) {
          _impl_.workernodeip_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dsloadbalancer.TaskInfo.workerNodeIp)
}

// string workerNodePort = 5;
inline void TaskInfo::clear_workernodeport() {
  _impl_.workernodeport_.ClearToEmpty();
}
inline const std::string& TaskInfo::workernodeport() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.TaskInfo.workerNodePort)
  return _internal_workernodeport();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskInfo::set_workernodeport(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.workernodeport_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dsloadbalancer.TaskInfo.workerNodePort)
}
inline std::string* TaskInfo::mutable_workernodeport() {
  std::string* _s = _internal_mutable_workernodeport();
  // @@protoc_insertion_point(field_mutable:dsloadbalancer.TaskInfo.workerNodePort)
  return _s;
}
inline const std::string& TaskInfo::_internal_workernodeport() const {
  return _impl_.workernodeport_.Get();
}
inline void TaskInfo::_internal_set_workernodeport(const std::string& value) {
  ;


  _impl_.workernodeport_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskInfo::_internal_mutable_workernodeport() {
  ;
  return _impl_.workernodeport_.Mutable( GetArenaForAllocation());
}
inline std::string* TaskInfo::release_workernodeport() {
  // @@protoc_insertion_point(field_release:dsloadbalancer.TaskInfo.workerNodePort)
  return _impl_.workernodeport_.Release();
}
inline void TaskInfo::set_allocated_workernodeport(std::string* value) {
  _impl_.workernodeport_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.workernodeport_.IsDefault()) {
          _impl_.workernodeport_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dsloadbalancer.TaskInfo.workerNodePort)
}

// string storageNodeIp = 6;
inline void TaskInfo::clear_storagenodeip() {
  _impl_.storagenodeip_.ClearToEmpty();
}
inline const std::string& TaskInfo::storagenodeip() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.TaskInfo.storageNodeIp)
  return _internal_storagenodeip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskInfo::set_storagenodeip(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.storagenodeip_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dsloadbalancer.TaskInfo.storageNodeIp)
}
inline std::string* TaskInfo::mutable_storagenodeip() {
  std::string* _s = _internal_mutable_storagenodeip();
  // @@protoc_insertion_point(field_mutable:dsloadbalancer.TaskInfo.storageNodeIp)
  return _s;
}
inline const std::string& TaskInfo::_internal_storagenodeip() const {
  return _impl_.storagenodeip_.Get();
}
inline void TaskInfo::_internal_set_storagenodeip(const std::string& value) {
  ;


  _impl_.storagenodeip_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskInfo::_internal_mutable_storagenodeip() {
  ;
  return _impl_.storagenodeip_.Mutable( GetArenaForAllocation());
}
inline std::string* TaskInfo::release_storagenodeip() {
  // @@protoc_insertion_point(field_release:dsloadbalancer.TaskInfo.storageNodeIp)
  return _impl_.storagenodeip_.Release();
}
inline void TaskInfo::set_allocated_storagenodeip(std::string* value) {
  _impl_.storagenodeip_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.storagenodeip_.IsDefault()) {
          _impl_.storagenodeip_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dsloadbalancer.TaskInfo.storageNodeIp)
}

// string storageNodePort = 7;
inline void TaskInfo::clear_storagenodeport() {
  _impl_.storagenodeport_.ClearToEmpty();
}
inline const std::string& TaskInfo::storagenodeport() const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.TaskInfo.storageNodePort)
  return _internal_storagenodeport();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaskInfo::set_storagenodeport(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.storagenodeport_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dsloadbalancer.TaskInfo.storageNodePort)
}
inline std::string* TaskInfo::mutable_storagenodeport() {
  std::string* _s = _internal_mutable_storagenodeport();
  // @@protoc_insertion_point(field_mutable:dsloadbalancer.TaskInfo.storageNodePort)
  return _s;
}
inline const std::string& TaskInfo::_internal_storagenodeport() const {
  return _impl_.storagenodeport_.Get();
}
inline void TaskInfo::_internal_set_storagenodeport(const std::string& value) {
  ;


  _impl_.storagenodeport_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskInfo::_internal_mutable_storagenodeport() {
  ;
  return _impl_.storagenodeport_.Mutable( GetArenaForAllocation());
}
inline std::string* TaskInfo::release_storagenodeport() {
  // @@protoc_insertion_point(field_release:dsloadbalancer.TaskInfo.storageNodePort)
  return _impl_.storagenodeport_.Release();
}
inline void TaskInfo::set_allocated_storagenodeport(std::string* value) {
  _impl_.storagenodeport_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.storagenodeport_.IsDefault()) {
          _impl_.storagenodeport_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dsloadbalancer.TaskInfo.storageNodePort)
}

// -------------------------------------------------------------------

// Result

// repeated .dsloadbalancer.KVPair hashMap = 1;
inline int Result::_internal_hashmap_size() const {
  return _impl_.hashmap_.size();
}
inline int Result::hashmap_size() const {
  return _internal_hashmap_size();
}
inline void Result::clear_hashmap() {
  _internal_mutable_hashmap()->Clear();
}
inline ::dsloadbalancer::KVPair* Result::mutable_hashmap(int index) {
  // @@protoc_insertion_point(field_mutable:dsloadbalancer.Result.hashMap)
  return _internal_mutable_hashmap()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dsloadbalancer::KVPair >*
Result::mutable_hashmap() {
  // @@protoc_insertion_point(field_mutable_list:dsloadbalancer.Result.hashMap)
  return _internal_mutable_hashmap();
}
inline const ::dsloadbalancer::KVPair& Result::_internal_hashmap(int index) const {
  return _internal_hashmap().Get(index);
}
inline const ::dsloadbalancer::KVPair& Result::hashmap(int index) const {
  // @@protoc_insertion_point(field_get:dsloadbalancer.Result.hashMap)
  return _internal_hashmap(index);
}
inline ::dsloadbalancer::KVPair* Result::_internal_add_hashmap() {
  return _internal_mutable_hashmap()->Add();
}
inline ::dsloadbalancer::KVPair* Result::add_hashmap() {
  ::dsloadbalancer::KVPair* _add = _internal_add_hashmap();
  // @@protoc_insertion_point(field_add:dsloadbalancer.Result.hashMap)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dsloadbalancer::KVPair >&
Result::hashmap() const {
  // @@protoc_insertion_point(field_list:dsloadbalancer.Result.hashMap)
  return _internal_hashmap();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::dsloadbalancer::KVPair>&
Result::_internal_hashmap() const {
  return _impl_.hashmap_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::dsloadbalancer::KVPair>*
Result::_internal_mutable_hashmap() {
  return &_impl_.hashmap_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace dsloadbalancer


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_dsloadbalancer_2eproto_2epb_2eh
